# 联动包

联动包允许您指定应该一起进行版本控制的一组或多组包。由于存在一些复杂情况，因此下面展示了一些示例，以演示各种情况。

- 只有在存在 changeset 时（这可能是因为您明确选择为其添加 changeset，或者因为它是正在发布的某些内容的依赖项），联动包才会被增加版本。
- 具有 changeset 并处于一组联动包中的包将**始终**版本化为联动包集中当前最高版本 + 联动包集中 changeset 中最高的升级类型。

> 与`fixed packages`不同，不能保证联动包组中的所有包都将被增加版本并发布，只有带有 changeset 的包将被增加版本。

## 示例

### 通用示例

我有三个包，`pkg-a`、`pkg-b` 和 `pkg-c`。`pkg-a` 和 `pkg-b` 是联动的，但 `pkg-c` 不是，因此配置如下。

```json
{
  "linked": [["pkg-a", "pkg-b"]]
}
```

- `pkg-a` 版本为 `1.0.0`
- `pkg-b` 版本为 `1.0.0`
- `pkg-c` 版本为 `1.0.0`

我有一个 changeset，对 `pkg-a` 进行了修补，对 `pkg-b` 进行了小版本更改，对 `pkg-c` 进行了主版本更改，然后我进行了发布，结果的版本将是：

- `pkg-a` 版本为 `1.1.0`
- `pkg-b` 版本为 `1.1.0`
- `pkg-c` 版本为 `2.0.0`

现在我有另一个 changeset，对 `pkg-a` 进行了小版本更改，然后我进行了发布，结果的版本将是：

- `pkg-a` 版本为 `1.2.0`
- `pkg-b` 版本为 `1.1.0`
- `pkg-c` 版本为 `2.0.0`

现在我有另一个 changeset，对 `pkg-b` 进行了小版本更改，然后我进行了发布，结果的版本将是：

- `pkg-a` 版本为 `1.2.0`
- `pkg-b` 版本为 `1.3.0`
- `pkg-c` 版本为 `2.0.0`

现在我有另一个 changeset，对所有三个包进行了修补，然后我进行了发布，结果的版本将是：

- `pkg-a` 版本为 `1.3.1`
- `pkg-b` 版本为 `1.3.1`
- `pkg-c` 版本为 `2.0.1`

### 带有依赖项的示例

我有两个包，`pkg-a`、`pkg-b` 是联动的。`pkg-a` 依赖于 `pkg-b`。

```json
{
  "linked": [["pkg-a", "pkg-b"]]
}
```

- `pkg-a` 版本为 `1.0.0`
- `pkg-b` 版本为 `1.0.0`

我有一个 changeset，对 `pkg-b` 进行了主版本更改，然后我进行了发布，结果的版本将是：

- `pkg-a` 版本为 `2.0.0`
- `pkg-b` 版本为 `2.0.0`

现在我有另一个 changeset，对 `pkg-a` 进行了主版本更改，然后我进行了发布，结果的版本将是：

- `pkg-a` 版本为 `3.0.0`
- `pkg-b` 版本为 `2.0.0`

## 使用 glob 表达式

有时您希望在项目中链接许多或所有包（例如在 monorepo 设置中），在这种情况下，您需要保持联动包列表的最新状态。

为了更容易维护该列表，您可以在联动列表中提供 glob 表达式，这些表达式将匹配并解析您希望包含的所有包。

例如：

```json
{
  "linked": [["pkg-*"]]
}
```

它将匹配所有以 `pkg-` 开头的包。

**Glob 表达式必须根据 [micromatch](https://www.npmjs.com/package/micromatch) 格式定义。**
